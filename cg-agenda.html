<link href="../polymer/polymer.html" rel="import">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../core-toolbar/core-toolbar.html">
<link rel="import" href="../core-icon-button/core-icon-button.html">
<link rel="import" href="../font-awesome-polymer-icons/fa-icons.html">
<link rel="import" href="../cg-datetime-picker/cg-date-picker-dialog.html">
<link rel="import" href="../cg-base/cg-base.html">
<link rel="import" href="cg-event-editor.html">

<script src="../jquery/dist/jquery.min.js"></script>

<polymer-element name="cg-agenda" extends="cg-base" attributes="events showLink date startDayOfWeek hourHeight showHour dragMinuteStep colors highlightedFn redrawOnApplicationEvents showAddEvent createDisabled">
    <template>
        <style>
            :host {
                display:block;
            }

            .noselect {
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            .hidden {
                display:none!important;
            }
            :host  {
                width: 100%;
                font-family: sans-serif;
            }
            :host .agendadays {
                height: 400px;
                overflow-y: auto;
                overflow-x: hidden;
            }
            :host .weekday,
            :host .agengaday {
                border-left:1px solid #ccc;
                text-align: center;
            }
            :host .weekday,
            :host .agengaday {
                margin:0 5px 0 5px;
            }
            :host .agengaday {
                height:{{hourHeight * 24}}px;
            }
            :host .event {
                background-color:#3498DB;
                position:absolute;
                border:1px solid white;
                border-radius: 10px;
                cursor: pointer;
                padding:0px 2px 0px 2px;
                z-index:1;
            }
            :host .event .header {
                font-weight: bold;
                font-size: 10px;
                color: white;
                text-align: left;
                margin: 3px 3px 0px 3px;
                white-space: nowrap;
                overflow: hidden;
            }
            :host .event .content {
                font-size: 11px;
                color: white;
                text-align: left;
                margin: 3px 3px 5px 1px;
                word-break: break-all;
                overflow: hidden;
            }
            :host .event .content:hover {
                text-decoration: underline;
            }
            :host .event:hover {
                z-index:2;
            }

            :host .event.resize {
                cursor:ns-resize;
            }
            :host .event.resize .footer .resizer,
            :host .event.eventend:hover .footer .resizer,
            :host .event.eventfull:hover .footer .resizer {
                border-bottom:1px solid white;
                cursor:ns-resize;
                height:5px;
                margin:3px;
            }
            :host .event.dd-ghost {
                opacity: 0.5!important;
                z-index:2;
            }
            :host .weekdays .day-name-large {
                text-align: center;
            }
            :host .weekdays .day-num {
                font-size: 2em;
            }
            :host .weekdays {
                margin-left:25px;
            }
            :host canvas {
                position: absolute;
                top:0; left:0;
                width:100%;
            }

            :host div#hours {
                position:relative;
                width:25px;
                font-family: "Oxygen Mono", Oxygen , monospace;
                font-size: .8em;
            }

            :host div#hours > div {
                position:absolute;
                right:5px;
            }
            :host #header{
                background-color: transparent;
            }

            :host #header .action-button /deep/ core-icon {
                color: rgb(0, 150, 136);
                margin-right: 5px;
            }
        </style>
        <div id="agenda" layout vertical flex>
            <core-toolbar id="header" class="header">
                <core-icon-button class="action-button" id="previous" icon="fa:caret-left" on-tap="{{_onPreviousWeek}}"></core-icon-button>
                <core-icon-button class="action-button" id="next" icon="fa:caret-right" on-tap="{{_onNextWeek}}"></core-icon-button>
                <template if="{{showAddEvent}}">
                    <core-icon-button class="action-button" id="create_icon_button" icon="create" on-tap="{{_onCreateEvent}}">Add event</core-icon-button>
                </template>
                <core-icon-button class="action-button" id="today_icon_button" icon="fa:calendar-o" on-tap="{{_onNowWeek}}">Today</core-icon-button>
                <core-icon-button class="action-button" id="calendar_button" icon="fa:calendar" on-tap="{{_onSelectWeek}}">{{_calendarWeekDisplay(_viewFrom, _viewTo)}}</core-icon-button>
                <!--<core-icon-button class="action-button" id="calendar_button" icon="fa:calendar" on-tap="{{redrawAll}}">REDRAW</core-icon-button>-->
            </core-toolbar>
            <div id="weekdays" class="weekdays noselect" layout horizontal>
                <template repeat="{{_weekDays as day}}">
                    <div flex class="weekday noselect" data-value="{{day.day}}" layout horizontal center>
                        <span flex class="day-name-large">{{_dayNameDisplay(day)}}</span>
                        <span class="day-num">{{_dayNumDisplay(day)}}</span>
                    </div>
                </template>
            </div>
            <div class="agendadays noselect" layout horizontal id="agendadays" relative
                 on-mousemove="{{_onMouseMove}}"
                 on-mouseover="{{_onDayOver}}"
                 on-dblclick="{{_onCalendarDblClick}}"
                 on-trackstart="{{_onEventDragStart}}"
                 on-track="{{_onEventDrag}}"
                 on-trackend="{{_onEventDragEnd}}">
                <canvas id="hoursCanvas" style="width:100%"></canvas>
                <div id="hours"></div>
                <template repeat="{{_weekDays as day}}">
                    <div flex class="agengaday noselect day" weekday data-day="{{day.day}}" data-month="{{day.month}}" data-year="{{day.year}}" relative>
                        <template repeat="{{_eventsInView as e}}">
                            <template if="{{_isEventOfDay(e, day, e.redraw)}}">
                                <div class="event noselect {{_getEventClass(e, day, e.redraw)}}"
                                     style="{{_getEventStyle(e, day, e.redraw)}}"
                                     event
                                     data-role="move"
                                     data-id="{{e._cgaId}}"
                                     data-day="{{day.day}}"
                                     layout vertical>
                                    <div class="header noselect">{{_eventRangeDisplay(e, day, e.redraw)}}</div>
                                    <div flex class="content noselect">
                                        <template if="{{showLink && e.links[showLink]}}"><strong>{{e.links[showLink].display}}</strong><br/></template>
                                        {{e.label}}
                                    </div>
                                    <div class="footer noselect">
                                        <div class="resizer" data-role="resize"></div>
                                    </div>
                                </div>
                            </template>
                        </template>
                        <div class="dd-overlay" id="dd-overlay-{{day.day}}"></div>
                    </div>
                </template>
            </div>
        </div>
    </template>
    <script>
        (function(){
            var CollisionGroup = function(event, that, id){
                this.from = new Date(event.from);
                this.to = new Date(event.to);
                this.events = [];
                this.that = that;
                this.addEvent(event, id)
            };
            CollisionGroup.prototype = {
                reorder:function(){
                    this.that.orderEvents(this.events, false);
                },
                _setId:function(event, id){
                    if(id == undefined || id == null) {
                        return;
                    }
                    event._collisionGroupId = id;
                },
                _removeId:function(event){
                    delete event._collisionGroupId;
                },
                setIds:function(id) {
                    for(var i=0; i<this.events.length;i++){
                        this._setId(this.events[i], id);
                    }
                },
                removeIds:function() {
                    for(var i=0; i<this.events.length;i++){
                        this._removeId(this.events[i]);
                    }
                },
                addEvents:function(events, id, reorder){
                    for(var i=0; i<events.length; i++){
                        this.addEvent(events[i], id, reorder);
                    }
                },
                addEvent:function(e, id, reorder){
                    this._setId(e, id);
                    this.events.push(e);
                    this.from = new Date(Math.min(e.from.getTime(), this.from.getTime()));
                    this.to = new Date(Math.max(e.to.getTime(), this.to.getTime()));
                    reorder === true && this.reorder();
                },
                removeEvent:function(e) {
                    var removed = this.events.splice(this.events.indexOf(e), 1);
                    if(removed.length == 1) {
                        this._removeId(e);
                        this.reorder();
                        if (this.events.length > 0) {
                            this.from = new Date(this.events[0].from);
                            this.to = new Date(this.events[0].to);
                            for (var i = 1; i < this.events.length; i++) {
                                this.from = new Date(Math.min(this.events[i].from.getTime(), this.from.getTime()));
                                this.to = new Date(Math.max(this.events[i].to.getTime(), this.to.getTime()));
                            }
                        }
                        return true;
                    }
                    return false;
                }
            };

            var IdGen = function() {
                this.id = 1;  
            };
            IdGen.prototype = {
                next:function(){
                    return this.id++;
                },
                reset:function(){
                    this.id = 1;
                }  
            };
            var CalendarManager = function(collisionCacheGroups){
                this.idGen = new IdGen(),
                this.cache = {
                    collisionGroups :{
                        enabled:collisionCacheGroups === false ? false : true,
                        idGen: new IdGen(),
                        cache:{},
                        disable:function(){
                            this.enabled = false;
                            this.flush();
                        },
                        enable:function(){
                            this.enabled = true;
                            this.flush();
                        },
                        nextId :function(){
                            return this.idGen.next();
                        },
                        size:function(){
                            return Object.keys(this.cache).length;
                        },
                        flush:function(){
                            for(var id in this.cache){
                                this.cache[id].removeIds();
                            }
                            this.cache = {};
                            this.idGen.reset();
                        }
                    },
                    reset:function(){
                        this.collisionGroups.disable();
                    }
                };
            };
            CalendarManager.prototype = {
                intersects: function(e1, e2){
                    var es1 = e1.from.getTime();
                    var ee1 = e1.to.getTime();
                    var es2 = e2.from.getTime();
                    var ee2 = e2.to.getTime();
                    return (es1 <= ee2 && es2 <= ee1 );
//                    return (s1 < s2 && e1 > s2) || (s1 >= s2 && (e1 < e2 || (s1 < e2))) || s1 <= s2 && e1 >= e2;
                },
                getEventsInView:function(events, view){
                    var inView = [];
                    events.forEach(function(e){
                        if(this.intersects(e, view)){
                            inView.push(e);
                        }
                    }.bind(this));
                    return inView;
                },
                getRedrawsCount:function(event){
                    // + 2 because redraw trigger gets used by isEventOfDay and getEventClass
                    return Math.ceil((event.to.getTime()-event.from.getTime())/(1000*60*60*24)) + 2;
                },
                minutediff:function(range) {
                    return (range.to.getTime()-range.from.getTime())/(1000*60);
                },
                orderEvents:function(events, copy){
                    events = copy === false ? events : events.slice();
                    events.sort(this.eventComparator);
                    return events;
                },
                setIds:function(events, reset){
                    reset === true && this.idGen.reset();
                    events.forEach(function(e){
                        this.setId(e);
                    }.bind(this));
                    return events;
                },
                setId:function(event) {
                    event._cgaId = event._cgaId || this.idGen.next();
                },
                reset:function(){
                    this.idGen.reset();
                    this.cache.reset();
                },
                eventComparator:function(a,b){
                    var aFrom = a.from.getTime();
                    var bFrom = b.from.getTime();
                    var aTo = a.to.getTime();
                    var bTo = b.to.getTime();
                    return  aFrom < bFrom ? -1 : aFrom > bFrom ? 1 : aTo < bTo ? 1 : aTo > bTo ? -1 : 0;
                },
                primeCollisionGroupCache:function(events){
                    console.log("[cg-agenda] Priming cache");
                    this.cache.collisionGroups.flush();
                    var groups = this.getCollisionGroup(events);
                    for(var i = 0; i < groups.length; i++){
                        var group = groups[i];
                        var id = this.cache.collisionGroups.nextId();
                        group.setIds(id);
                        this.cache.collisionGroups.cache[id] = group;
                    }
                    console.log("[cg-agenda] Priming cache done [size " + this.cache.collisionGroups.size() + ", event count:" + events.length + "]");
                },
                invalidateCollisionGroupCache:function(event){
                    //console.log("Event " + event._cgaId + " needs to be removed from cache.");
                    var oldGroupId = event._collisionGroupId;
                    var cachedGroup = this.cache.collisionGroups.cache[oldGroupId];
                    var collisionGroup;
                    if(cachedGroup && cachedGroup.removeEvent(event)) {
                        //console.log("Event " + event_cgaId + ": Cached group found, removing from it.");
                        if(cachedGroup.events.length == 0) {
                            //console.log("Event " + event._cgaId + ": Old cached group is now empty, deleting it from cache");
                            delete this.cache.collisionGroups.cache[oldGroupId];
                            collisionGroup = [cachedGroup];
                        }else{
                            //console.log("Event " + event._cgaId + ": Old cached group might needs splitting, performing collision search onto its content.");
                            var cachedGroupCollisionGroups = this.getCollisionGroup(cachedGroup.events);
                            if(cachedGroupCollisionGroups.length == 1) {
                                //console.log("Event " + event._cgaId + ": Old cached group is still a single collision group, keeping it.");
                            }else{
                                //console.log("Event " + event._cgaId + ": Old cached group is now broken into " + cachedGroupCollisionGroups.length + " distinct groups. Removing old cached group from cache and caching new ones.");
                                for(var i=0; i < cachedGroupCollisionGroups.length; i++){
                                    var groupId = this.cache.collisionGroups.nextId();
                                    var cachedGroupCollisionGroup = cachedGroupCollisionGroups[i];
                                    cachedGroupCollisionGroup.setIds(groupId);
                                    this.cache.collisionGroups.cache[groupId] = cachedGroupCollisionGroup;
                                }
                                delete this.cache.collisionGroups.cache[oldGroupId];
                            }
                            collisionGroup = cachedGroupCollisionGroups;
                        }
                    }else{
                        //console.log("Event " + event._cgaId + ": Cannot remove from cache as not found cached group not found.")
                        collisionGroup = [{events:[]}];
                    }
                    return collisionGroup;
                },
                findCollisionGroup:function(events, event, order, flushFromCache){
                    if(this.cache.collisionGroups.enabled === false) {
                        //console.log("[Cache disabled]");
                        return this.getCollisionGroup(events, event, order);
                    }

                    var collisionGroup;
                    if(flushFromCache === true) {
                        collisionGroup = this.invalidateCollisionGroupCache(event);
                    }else if(event._collisionGroupId != undefined) {
                        //console.log("Event " + event._cgaId + " has a collisionGroupId, looking it up.")
                        var cachedGroup = this.cache.collisionGroups.cache[event._collisionGroupId];
                        if(cachedGroup) {
                            //console.log("Event " + event._cgaId + " cached collision group found, using it.")
                            //console.log("[Cache HIT]");
                            collisionGroup = [cachedGroup]
                        }else{
                            //console.log("Event " + event._cgaId + " cached collision group NOT found.")
                            throw "Event " + event._cgaId + " cached collision group NOT found.";
                        }
                    }else{
                        //console.log("Event " + event._cgaId + " hasn't got a collisionGroupId, trying to find suitable cached groups.");
                        var suitableCachedGroups = {};
                        var groups = 0;
                        for(var id in this.cache.collisionGroups.cache){
                            var group = this.cache.collisionGroups.cache[id];
                            if(this.intersects(event, group)) {
                                suitableCachedGroups[id] = group;
                                groups++;
                            }
                        }
                        if(groups > 0) {
                            //console.log("Event " + event._cgaId + ": found " + groups + " suitable cached groups.");
                            //console.log("[Cache HIT]");
                            if(groups == 1){
                                //console.log("Event " + event._cgaId + ": Adding it to single suitable cached group found.");
                                var groupId = Object.keys(suitableCachedGroups)[0];
                                var cachedGroup = suitableCachedGroups[groupId];
                                cachedGroup.addEvent(event, groupId, true);
                                collisionGroup = [cachedGroup];
                            }else{
                                //console.log("Event " + event._cgaId + ": More than one suitable cached group found. Merging groups and adding event");
                                var mergedGroupId = this.cache.collisionGroups.nextId();
                                var mergedGroup = new CollisionGroup(event, this, mergedGroupId);
                                for(var groupId in suitableCachedGroups){
                                    mergedGroup.addEvents(suitableCachedGroups[groupId].events, mergedGroupId);
                                    //console.log("Event " + event._cgaId + ": Removing stale cache group from cache");
                                    delete this.cache.collisionGroups.cache[groupId];
                                }
                                mergedGroup.reorder();
                                this.cache.collisionGroups.cache[mergedGroupId] = mergedGroup;
                                collisionGroup = [mergedGroup];
                            }
                        }else{
                            //console.log("Event " + event._cgaId + ": No suitable cached groups found, performing deep collision group search and caching result.");
                            //console.log("[Cache MISS]");
                            var newGroupId = this.cache.collisionGroups.nextId();
                            collisionGroup = this.getCollisionGroup(events, event, order)[0];
                            collisionGroup.setIds(newGroupId);
                            this.cache.collisionGroups.cache[newGroupId] = collisionGroup;
                            collisionGroup = [collisionGroup];
                        }

                    }
                    //console.log("Cache size " + this.cache.collisionGroups.size());
                    return collisionGroup;
                },
                getCollisionGroup:function(events, event, order){
                    if(events.length == 0) {
                        return [];
                    }
                    events = order === false ? events.slice() : this.orderEvents(events);
                    var e = events.splice(event ? events.indexOf(event) : 0, 1)[0];
                    var groups = [new CollisionGroup(e, this)];

                    var c = 0, i, j, e, found, group;
                    while(events.length > 0){
                        found = false;
                        e = events[c];
                        for(i = 0; i < groups.length; i++){
                            group = groups[i];
                            if(this.intersects(e, group)) {
                                group.addEvent(e);
                                found = true;
                                break;
                            }
                        }
                        if(!found) {
                            if(event) {
                                if(++c == events.length) {
                                    events.splice(0, 1);
                                    c = 0;
                                }
                            }else{
                                events.splice(0, 1);
                                groups.push(new CollisionGroup(e, this));
                            }
                        }else{
                            events.splice(c, 1);
                            c = 0;
                        }
                    }
                    for(i = 0; i < groups.length; i++){
                        groups[i].reorder();
                    }

                    return groups;
                },
                getCollisionFreeMatrix:function(collisionGroup, copy){
                    var events = copy === false ? collisionGroup.events : collisionGroup.events.slice();
                    var matrix = [events.splice(0,1)];
                    var columnIndex = 0, column, b, found, c;
                    while(events.length > 0){
                        column = matrix[columnIndex];
                        b = events[0];
                        found = false;
                        for(c = 0; c < column.length; c++){
                            if(this.intersects(column[c], b)) {
                                found = true;
                                break;
                            }
                        }
                        if(!found) {
                            column.push(b);
                            events.splice(0, 1);
                            columnIndex = 0;
                        }else{
                            columnIndex++;
                            if(columnIndex == matrix.length) {
                                matrix.push([b]);
                                events.splice(0, 1);
                                columnIndex = 0;
                            }
                        }
                    }
                    return matrix;
                },
                findCollisionMatrixInfoForSingleEvent:function(events, event, order, invalidateCache){
                    var group = this.findCollisionGroup(events, event, order, invalidateCache);
                    var matrix = this.getCollisionFreeMatrix(group[0]);
                    var columnIndex = 0;
                    var totalColumns = matrix.length, i, column;
                    out: for(; columnIndex < matrix.length; columnIndex++){
                        column = matrix[columnIndex];
                        for(i=0; i < column.length; i++){
                            if(column[i] == event) {
                                break out;
                            }
                        }
                    }
                    return {
                        column:columnIndex + 1,
                        totalColumns:totalColumns
                    };
                }
            };

            Polymer("cg-agenda", {
                date:new Date(),
                showAddEvent:true,
                createDisabled:false,
                startDayOfWeek:1,
                hourHeight:60,
                showHour:9,
                dragMinuteStep:15,
                defaultColor: {name:"Bold Blue", mask:"#5484ED"},
                colors:null,
                highlightedFn:function(data){return true},
                dataTagPrefix:"cg-agenda",
                redrawOnApplicationEvents:null,
                _eventSizeCacheThreshold:50,
                _draggingTerminateTimeout:1000,
                _dayOver:null,
                _eventOver:null,
                _viewFrom:null,
                _viewTo:null,
                _weekDays:null,
                _providedEvents:false,
                _events:null,
                _eventsMap:{},
                _eventsInView:null,
                _initialDragInfos:null,
                _timeFormat : Intl.DateTimeFormat(this.locale, {hour:'2-digit', minute:'2-digit', hour12:false}),
                _headerDateFormat : Intl.DateTimeFormat(this.locale, {day:'2-digit', month:'long'}),
                _dayNameFormat : Intl.DateTimeFormat(this.locale, {weekday:'long'}),
                _dayNumFormat : Intl.DateTimeFormat(this.locale, {day:'2-digit'}),
                _monthNumFormat : Intl.DateTimeFormat(this.locale, {month:'2-digit'}),
                _manager:null,
                _editorSource:null,
                created:function(){
                    this.super();
                    this.super();
                    this.redrawOnApplicationEvents = [];
                    this._weekDays = [];
                    this._events = [];
                    this._eventsInView = [];
                    this._editorSource = {};
                },
                ready:function(){
                    this._manager = new CalendarManager(true);
                    this.addEventListener("event-drag-end", this._onEventDragEnded.bind(this));

                },
                _dayNumDisplay:function(day) {
                    return this._dayNumFormat.format(day.date) + "/" + this._monthNumFormat.format(day.date);
                },
                _dayNameDisplay:function(day) {
                    return this._dayNameFormat.format(day.date);
                },
                _calendarWeekDisplay:function(from, to){
                    if(!from || !to) {
                        return;
                    }
                    var fromYear = from.getFullYear() != to.getFullYear() ? " " + from.getFullYear() : "";
                    return this._headerDateFormat.format(from) + fromYear + " - " + this._headerDateFormat.format(to) + " " + to.getFullYear();
                },
                domReady:function(){
                    this.super();
                    console.log("[cg-agenda] domReady");
                    this.$.datepicker = this.globals.dateDialog || this.shadowRoot.appendChild(document.createElement('cg-date-picker-dialog'));
                    this.$.eventEditor = this.globals.eventEditor || this.shadowRoot.appendChild(this._createEditor());
                    this.$.weekdays.style.marginRight = (this.$.agendadays.offsetWidth - this.$.agendadays.clientWidth) + "px";
                    this._drawBackground();
                    this.dateChanged();
                    this.$.agendadays.scrollTop = (this.hourHeight * this.showHour);
                    console.log("[cg-agenda] Agenda init [from:" + this._viewFrom + ", to:" + this._viewTo + "]");
                },
                _createEditor:function(){
                    var editor = document.createElement("cg-event-editor");
                    editor.setAttribute("categories", "{{categories}}");
                    editor.setAttribute("colors", "{{colors}}");
                    editor.setAttribute("showMetaData", "{{showMetaData}}");
                    return editor;
                },
                redrawAll:function(){
                    this._eventsInView.forEach(function(e){
                        e.redraw = this._manager.getRedrawsCount(e);
                    }.bind(this));
                },
                set events(events){
                    this._providedEvents = true;
                    this._events = events;
                },
                _refreshEventsInView:function(){
                    var range = {from:this._viewFrom, to:this._viewTo};
                    if(this._providedEvents) {
                        console.log("[cg-agenda] Agenda - Events provided, using them");
                        this._setEvents(this._manager.getEventsInView(this.events, range));
                    }else{
                        console.log("[cg-agenda] Agenda - Events not provided, firing data request");
                        this.fireDataRequest({
                            type:"events-in-range",
                            params:range,
                            success:function(response){
                                this._setEvents(response.data);
                            }.bind(this),
                            failure:function(response){}.bind(this)
                        });
                    }
                },
                onApplicationEvent:function(type, event){
                    if(event.source == this) {
                        console.log("[cg-agenda] onApplicationEvent(type:'"+type+"') source is self, ignoring");
                        return;
                    }
                    if(event.source == this._editorSource) {
                        console.log("[cg-agenda] onApplicationEvent(type:'"+type+"') source is known, updating data");
                        switch(type) {
                            case "event-updated":
                            case "event-created":
                                event = event.params;
                                var newRange = {
                                    from:event.from,
                                    to:event.to
                                };
                                var op = type == "event-updated" ? "edit" : "create";
                                event.from = event._from || event.from;
                                event.to = event._to || event.to;
                                delete event._from;
                                delete event._to;
                                this._commitEventChange(event, newRange, op);
                                break;
                            case "event-deleted":
                                this._commitEventChange(event.params, null, "delete");
                                break;
                        }
                    }else{
                        switch(type){
                            case "agenda-create-event":
                                this.createEvent();
                                break;
                            case "event-updated":
                            case "event-created":
                            case "event-deleted":
                                console.log("[cg-agenda] onApplicationEvent(type:'"+type+"') source is unknown, trigger data refresh");
                                if (this._manager.intersects(event.params, {
                                            from: this._viewFrom,
                                            to: this._viewTo
                                        })) {
                                    console.log("[cg-agenda] received event update. Event is in view. Refreshing datas");
                                    this.doIfVisible(this._refreshEventsInView);
                                } else {
                                    console.log("[cg-agenda] received event update. Event is not in view. Ignoring");
                                }
                                break;
                        }
                    }
                    if(this.redrawOnApplicationEvents && this.redrawOnApplicationEvents.indexOf(type) != -1) {
                        this.redrawAll();
                    }
                },
                _setEvents:function(events){
                    this._manager.orderEvents(events, false);
                    this._events = this._manager.setIds(events, true);
                },
                _eventsChanged:function(){
//                    console.log("_refreshEventsInView")
                    var eventsInView = this._events.slice();
                    if(eventsInView.length < this._eventSizeCacheThreshold) {
                        console.log("[cg-agenda] Event in view size (" + eventsInView.length + ") within cache threshold ("+ this._eventSizeCacheThreshold+"). Cache disabled. ");
                        this._manager.cache.collisionGroups.disable();
                    }else{
                        console.log("[cg-agenda] Event in view size (" + eventsInView.length + ") exceed cache threshold ("+ this._eventSizeCacheThreshold+"). Cache enabled. ");
                        this._manager.cache.collisionGroups.enable();
                        this._manager.primeCollisionGroupCache(eventsInView);
                    }
                    var eventsMap = {};
                    eventsInView.forEach(function(e){
                        eventsMap[e._cgaId] = e;
                    }.bind(this));

                    this._eventsInView = eventsInView;
                    this._eventsMap = eventsMap;
                    this.redrawAll();
                },
                get events(){
                    return this._events;
                },
                _onDayOver:function(e){
                    var dayElement = e.target;
                    while(!dayElement.hasAttribute("weekday") && dayElement != e.currentTarget) dayElement = dayElement.parentElement;
                    if(dayElement == e.currentTarget) return;
                    this._dayOver = {
                        day: Number(dayElement.dataset.day),
                        month: Number(dayElement.dataset.month),
                        year: Number(dayElement.dataset.year)
                    };
                },
                _onMouseMove:function(e){
                    var position = e.clientY - this._getAbsolutePosition(this.$.agendadays).top - this.hourHeight / 2;
                    this._hoursOver = this._getHoursForHeight(position);
                },
                dateChanged:function(){
                    var date = new Date(this.date.getFullYear(), this.date.getMonth(), this.date.getDate(), 0, 0, 0, 0);
                    var startDay = date.getDate() - date.getDay() + (this.startDayOfWeek % 7);
                    var weekDays = [];
                    date.setDate(startDay);
                    this._viewFrom = new Date(date);
                    for(var i = startDay; i < startDay + 7; i++){
                        var from = new Date(date);
                        var to = new Date(date);
                        to.setHours(23,59,59,999);
                        weekDays.push({
                            day:date.getDate(),
                            month:date.getMonth(),
                            year:date.getFullYear(),
                            date:new Date(date),
                            from:from,
                            to:to,
                        });
                        date.setDate(date.getDate() + 1);
                    }
                    this._viewTo = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999);
                    this._weekDays = weekDays;
                    this._refreshEventsInView();
                },
                _onPreviousWeek:function(){
                    this._addWeek(-1);
                },
                _onNextWeek:function(){
                    this._addWeek(1);
                },
                _addWeek:function(weeks){
                    this.date.setDate(this.date.getDate() + (weeks * 7));
                    this.date = new Date(this.date);
                },
                _onNowWeek:function(){
                    this.date = new Date();
                },
                _onCreateEvent:function(){
                    this.createEvent();
                },
                _onSelectWeek:function(){
                    this.$.datepicker.open(this.date, function(e){
                        this.date = new Date(e.detail);
                    }.bind(this));
                },
                _onCalendarDblClick:function(e){
                    e.stopPropagation();
                    var eventElement = e.target;
                    while(!eventElement.hasAttribute("event") && eventElement != e.currentTarget) eventElement = eventElement.parentElement;
                    if(eventElement != e.currentTarget) {
                        return this.openEvent(eventElement.dataset.id);
                    }else {
                        var event = {
                            from:new Date(this._dayOver.year, this._dayOver.month, this._dayOver.day, this._hoursOver, 0, 0 ,0),
                            to:new Date(this._dayOver.year, this._dayOver.month, this._dayOver.day, this._hoursOver + 1, 0, 0 ,0)
                        };
                        if(!this.createDisabled) {
                            this.createEvent(event);
                        }else{
                            this.fireApplicationEvent("create-event-request", event);
                        }
                    }
                },
                openEvent:function(eventId){
                    var event = this._getEventById(eventId);
                    event._from = event.from;
                    event._to = event.to;
                    this.$.eventEditor.openDialog(event, undefined, this._editorSource);
                },
                createEvent:function(event){
                    this.$.eventEditor.openDialog(event || {}, false, this._editorSource);
                },
                _onEventDragStart:function(e){
                    e.preventDefault();
                    e.stopPropagation();
                    var eventElement = e.target;
                    var roleElement = eventElement;
                    while(!roleElement.dataset.hasOwnProperty("role") && roleElement != e.currentTarget) roleElement = roleElement.parentElement;
                    if(roleElement == e.currentTarget) return;

                    while(!eventElement.hasAttribute("event") && eventElement != e.currentTarget) eventElement = eventElement.parentElement;
                    if(eventElement == e.currentTarget) return;

                    var eventId = eventElement.dataset.id;
                    var event = this._eventsMap[eventId];
                    event._dragging = true;
                    var eventElements = [].slice.call(this.$.agendadays.querySelectorAll(".event[data-id='" + eventId + "']"));
                    var eventElementsPerDay = {};
                    for(var i = 0; i < this._weekDays.length; i++){
                        eventElementsPerDay[this._weekDays[i].day] = {
                            day:this._weekDays[i],
                            dayDDOverlayEl:this.$.agendadays.querySelector("#dd-overlay-" + this._weekDays[i].day),
                            cloneEl:null,
                            originalEl:null
                        };
                    }
                    eventElements.forEach(function(eventElement){
                        var day = eventElement.dataset.day;
                        var clone = eventElement.cloneNode(true);
                        eventElement.classList.add("hidden");
                        clone.classList.add("dd-ghost");
                        eventElementsPerDay[day].originalEl = eventElement;
                        eventElementsPerDay[day].cloneEl = clone;
                        eventElementsPerDay[day].dayDDOverlayEl.appendChild(clone);
                    }.bind(this));

                    var that = this;
                    this._initialDragInfos = {
                        role: roleElement.dataset.role,
                        elements:eventElementsPerDay,
                        event:event,
                        mouseY:e.clientY,
                        lastDayDiff:null,
                        lastMinStep:null,
                        dayOver:this._dayOver.day,
                        lastDayOver:this._dayOver.day,
                        to:new Date(event.to),
                        from:new Date(event.from),
                        fireUpdated:function(){
                            this._cancelTask != undefined && that.cancelAsync(this._cancelTask);
                            this._cancelTask = that.async(function(){
                                this._onEventDragEnd("canceled-by-timeout");
                            }.bind(that), null, that._draggingTerminateTimeout);
                        },
                        fireFinished:function(){
                            this._cancelTask != undefined && that.cancelAsync(this._cancelTask);
                        }
                    };
                },
                _onEventDrag:function(e){
                    e.preventDefault();
                    e.stopPropagation();
                    if(!this._initialDragInfos) {
                        return;
                    }
                    var minutes = this._getMinutesForHeight(e.clientY - this._initialDragInfos.mouseY);

                    var to = new Date(this._initialDragInfos.to);
                    to.setMinutes(this._initialDragInfos.to.getMinutes() + minutes);
                    var minDiff = Math.abs((to.getTime() - this._initialDragInfos.to.getTime()) / 1000 / 60);

                    if ((this._dayOver.day != this._initialDragInfos.lastDayOver) || ((minDiff >= this.dragMinuteStep || minDiff == 0) && this._initialDragInfos.lastMinStep != minDiff)) {
                        var from = new Date(this._initialDragInfos.from);
                        this._initialDragInfos.role == "move" && from.setMinutes(from.getMinutes() + minutes);

                        var dayDiff = this._dayOver.day - this._initialDragInfos.dayOver;
                        from.setDate(from.getDate() + dayDiff);
                        to.setDate(to.getDate() + dayDiff);
                        var range = {from:from, to:to};

                        var diff = this._manager.minutediff(range);
                        if(this._initialDragInfos.role == "resize" && diff < this.dragMinuteStep * 2) {
                            to.setMinutes(to.getMinutes() + Math.abs(diff) + this.dragMinuteStep * 2);
                        }

                        var oldFrom =  this._initialDragInfos.dragging ? this._initialDragInfos.dragging.from : this._initialDragInfos.from;
                        var oldTo = this._initialDragInfos.dragging ? this._initialDragInfos.dragging.to : this._initialDragInfos.to;

                        this._initialDragInfos.dragging = range;
                        this._initialDragInfos.lastMinStep = minDiff;
                        this._initialDragInfos.lastDayOver = this._dayOver.day;

                        var fromDayDiff =  from.getDate() - oldFrom.getDate();
                        var toDayDiff =  to.getDate() - oldTo.getDate();

                        var daySwapEventElements = function(dayDiff, oldDate, isFrom) {
                            if(dayDiff != 0 && this._initialDragInfos.elements.hasOwnProperty(String(oldDate.getDate()))) {
                                var el = this._initialDragInfos.elements[oldDate.getDate()].cloneEl;
                                var toDay = oldDate.getDate() + dayDiff;
                                if(this._initialDragInfos.elements.hasOwnProperty(String(toDay)) && el) {
                                    var dayDef = this._initialDragInfos.elements[String(toDay)];
                                    dayDiff = isFrom ? -dayDiff : dayDiff;
                                    if(dayDiff > 0) {
                                        el = el.cloneNode(true);
                                        dayDef.cloneEl = el;
                                        dayDef.dayDDOverlayEl.appendChild(el);
                                    }else{
                                        el.parentElement.removeChild(el);
                                        this._initialDragInfos.elements[oldDate.getDate()].cloneEl = null;
                                        if(dayDef.cloneEl == null) {
                                            dayDef.cloneEl = el;
                                            dayDef.dayDDOverlayEl.appendChild(el);
                                        }
                                    }
                                }
                            }
                        }.bind(this);

                        daySwapEventElements(fromDayDiff, oldFrom, true);
                        daySwapEventElements(toDayDiff, oldTo, false);

                        for(var day in this._initialDragInfos.elements) {
                            var el = this._initialDragInfos.elements[day];
                            if(el == null || el.cloneEl == null) continue;
                            var box = this._getEventBoxFor(this._initialDragInfos.dragging, day, this._initialDragInfos.event);
                            el.cloneEl.setAttribute("style", box.toStyleString());
                            el.cloneEl.querySelector(".header").innerText = this._eventRangeDisplay(this._initialDragInfos.dragging, el.day);
                        }
                    }
                    this._initialDragInfos.fireUpdated();
                },
                _onEventDragEnd:function(e){
                    e && typeof e != "string" && e.preventDefault() && e.stopPropagation();
                    if (this._initialDragInfos && this._initialDragInfos.dragging) {
                        this._initialDragInfos.fireFinished();
                        var elements = [];
                        var overlays = [];
                        for(var day in this._initialDragInfos.elements) {
                            var el = this._initialDragInfos.elements[day];
                            if(el.cloneEl == null && el.originalEl == null) continue;
                            el.originalEl && elements.push(el.originalEl);
                            el.cloneEl && overlays.push(el.cloneEl);
                        }
                        var data = {
                            event:this._initialDragInfos.event,
                            newPosition: this._initialDragInfos.dragging,
                            elements:elements,
                            overlays:overlays
                        };
                        data.commitDrop = function(){
                            delete this.event._dragging;
                            this.elements.forEach(function(e){
                                e.classList.remove("hidden");
                            });
                            this.overlays.forEach(function(e){
                                e.parentElement.removeChild(e)
                            });
                        }.bind(data);

                        this.fire("event-drag-end", data);
                        delete this._initialDragInfos;
                    }
                },
                _onEventDragEnded:function(e){
                    if(this.isDataAware()) {
                        var toSave = Platform.mixin({}, e.detail.event, e.detail.newPosition);
                        this.fireDataRequest({
                            type:"save",
                            params:{event:toSave},
                            success:function(response){
                                this._onEventDragEndedCommitted(e, response.data);
                            }.bind(this),
                            failure:function(response){}.bind(this)
                        });
                    }else{
                        this._onEventDragEndedCommitted(e);
                    }
                },
                _onEventDragEndedCommitted:function(e, toFire){
                    this._commitEventChange(e.detail.event, e.detail.newPosition, "edit");
                    e.detail.commitDrop();
                    this.fireApplicationEvent("event-updated", toFire || e.detail.event);
                },
                _commitEventChange:function(event, newRange, operation) {
                    if(operation == "edit" || operation == "delete") {
                        var oldGroup = this._manager.findCollisionGroup(this._eventsInView, event, true, true);
                        oldGroup.forEach(function (group) {
                            group.events.forEach(function (event) {
                                //console.log("Trigger redraw for old group event: " + event._cgaId + " of group " + group.from + " - " + group.to);
                                event.redraw = this._manager.getRedrawsCount(event);
                            }.bind(this));
                        }.bind(this));
                    }

                    if(operation == "edit" || operation == "create") {
                        if(operation == "create") {
                            this._manager.setId(event);
                            this._eventsInView.push(event);
                            this._events.push(event);
                            this._eventsMap[event._cgaId] = event;
                        }
                        event.from = newRange.from;
                        event.to = newRange.to;
                        var newGroup = this._manager.findCollisionGroup(this._eventsInView, event, true);
                        newGroup.forEach(function(group){
                            group.events.forEach(function(event){
                                //console.log("Trigger redraw for new group event: " + event._cgaId + " of group " + group.from + " - " + group.to);
                                event.redraw = this._manager.getRedrawsCount(event);
                            }.bind(this));
                        }.bind(this));
                    }else if(operation == "delete"){
                        this._eventsInView.splice(this._eventsInView.indexOf(event), 1);
                        this._events.splice(this._events.indexOf(event), 1);
                    }

                    event.redraw = this._manager.getRedrawsCount(event);
                    // TODO PLUS AN ASYNC, FOR SOME REASON A IMMEDIATE REDRAW COULD DRAW STALE EVENT
                    this.async(function(){
                        event.redraw = this._manager.getRedrawsCount(event);
                    }.bind(this), null, 5)
                    this.fire("event-changed", {
                        event:event,
                        operation:operation
                    });
                },
                _eventRangeDisplay:function(range, day){
                    if(!range) return;
                    var from = range.from.getDate() == day.day ? this._timeFormat.format(range.from) : "";
                    var to = range.to.getDate() == day.day ? this._timeFormat.format(range.to) : "";
//                    return e._cgaId;
                    return from + (from && to ? " - " : "") + to;
                },
                _getEventById:function(id) {
                    return this._eventsMap[id]
                },
                _isEventOfDay:function(event, day){
                    //console.log(event.from + " - " + new Date(day.year, day.month, day.day, 23, 59 ,59, 999));
                    return this._manager.intersects(event, day);
                },
                _getEventClass:function(event, day){
                    return event.from.getDate() == day.day && event.to.getDate() == day.day ? "eventfull" :
                           event.from.getDate() == day.day ? "eventstart" :
                           event.to.getDate() == day.day ? "eventend" : "eventpart";
                },
                _getEventStyle:function(event, day){
//                    console.log("_getEventStyle event.redraw=" + event.redraw + " - day = " + JSON.stringify(day))
                    if(event.redraw == undefined) {
                        var el = this.$.agendadays.querySelector(".event[data-id='" + event._cgaId + "'][data-day='" + day.day + "']");
                        //console.log( el && el.getAttribute("style"))
                        return el && el.getAttribute("style");
                    }

                    var info = this._manager.findCollisionMatrixInfoForSingleEvent(this._eventsInView, event);
                    var box = this._getEventBoxFor(event, day.day, event);
                    box.left = (box.width / info.totalColumns) * (info.column - 1);
                    box.width = box.width / info.totalColumns;

                    if(event.redraw == 1) {
                        delete event.redraw;
                    }else{
                        event.redraw--;
                    }
                    return box.toStyleString();
                },
                _getEventBoxFor:function(range, day, event){
                    var top = range.from.getDate() == day ? this._getHeightForDate(range.from) : 0;
                    var height = this._getHeightForDate(range.to.getDate() == day ? range.to : new Date(range.to.getFullYear(), range.to.getMonth(), range.to.getDate(), 23, 59)) - top;
                    var opacity = this.highlightedFn(event) ? 1.0 : .2;
                    return {
                        top:top,
                        height:height,
                        width:100,
                        left:0,
                        opacity:opacity,
                        backgroundColor:event && event.color ? event.color.mask : this.defaultColor.mask,
                        toStyleString:function(additional){
                            return "top:" + this.top + "px;height:" + this.height + "px;width:" + this.width + "%;left:" + this.left + "%;background-color:" + this.backgroundColor + ";opacity:" + this.opacity;
                        }
                    };
                },
                _getHeightForDate:function(date){
                    return ((date.getHours() + (date.getMinutes() / 60.0)) * this.hourHeight);
                },
                _getMinuteHeight:function(){
                    return this.hourHeight / (60.0 / this.dragMinuteStep);
                },
                _getHoursForHeight:function(height){
                    return Math.floor(height / this.hourHeight);
                },
                _getMinutesForHeight:function(height){
                    var minuteHeight = this._getMinuteHeight();
                    return Math.round(height / minuteHeight) * this.dragMinuteStep;
                },
                _getAbsolutePosition:function(element) {
                    var top = 0, left = 0;
                    do {
                        top += element.offsetTop  || 0;
                        left += element.offsetLeft || 0;
                        top -= element.scrollTop  || 0;
                        left -= element.scrollLeft || 0;
                        element = element.offsetParent;
                    } while(element);

                    return {
                        top: top,
                        left: left
                    };
                },
                _drawBackground: function() {
                    this._drawBackgroundLines();
                    this._drawHours();
                },
                _drawBackgroundLines:function(){
                    var canvas = this.$.hoursCanvas;
                    canvas.width  = this.$.agenda.offsetWidth;
                    canvas.height = 24 * this.hourHeight;
                    canvas.style.height = canvas.height + "px";
                    var i, ctx = canvas.getContext("2d");
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = "#eeeeee";
                    for (i = 0; i < 24; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, (i + 0.5) * this.hourHeight + 0.5);
                        ctx.lineTo(canvas.width, (i + 0.5) * this.hourHeight);
                        ctx.stroke();
                    }
                    ctx.strokeStyle = "#ccc";
                    for (i = 0; i < 24; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, (i + 1) * this.hourHeight + 0.5);
                        ctx.lineTo(canvas.width, (i + 1)* this.hourHeight);
                        ctx.stroke();
                    }
                },
                _drawHours:function(){
                    function pad(n, width, z) {
                        z = z || '0';
                        n = n + '';
                        return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
                    }
                    var i, div;
                    var df = document.createDocumentFragment();
                    for (i = 0; i < 24; i++) {
                        div = document.createElement("div");
                        div.innerHTML = pad(i, 2);
                        div.style.top = ( (i) * this.hourHeight) + "px";
                        df.appendChild(div);
                    }
                    this.$.hours.appendChild(df);
                }
            });
        })();
    </script>
</polymer-element>