<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-styles/paper-styles.html">
<link rel="import" href="../font-awesome-polymer-icons/fa-icons.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-toolbar/paper-toolbar.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-fab/paper-fab.html">
<link rel="import" href="../cg-behaviors/cg-base-behavior.html">
<link rel="import" href="../cg-behaviors/cg-application-event-behavior.html">
<link rel="import" href="../cg-behaviors/cg-application-datasource-aware-behavior.html">
<link rel="import" href="../cg-behaviors/cg-application-context-behavior.html">
<link rel="import" href="../cg-utils/cg-utils.html">

<dom-module id="cg-agenda">
    <style>
        :host {
            @apply(--paper-font-body1);
            display:block;
            width: 100%;
            font-family: sans-serif;
        }

        #agenda .noselect {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        #agenda .hidden {
            display:none!important;
        }
        #agenda .agendadays {
            height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        #agenda .weekday,
        #agenda .agengaday {
            border-left:1px solid #ccc;
            text-align: center;
        }
        #agenda .weekday,
        #agenda .agengaday {
            margin:0 5px 0 5px;
        }
        #agenda .event {
            background-color:#3498DB;
            position:absolute;
            border:1px solid white;
            border-radius: 10px;
            cursor: pointer;
            padding:0px 2px 0px 2px;
            z-index:1;
        }
        #agenda .event .header {
            @apply(--paper-font-caption);
            font-size: 10px!important;
            line-height: 12px!important;
            color: white;
            text-align: left;
            margin: 3px 3px 0px 3px;
            white-space: nowrap;
            overflow: hidden;
        }
        #agenda .event .content {
            @apply(--paper-font-caption);
            font-size: 11px!important;
            line-height: 13px!important;
            color: white;
            text-align: left;
            margin: 3px 3px 5px 1px;
            word-break: break-all;
            overflow: hidden;
        }
        #agenda .event .content:hover {
            text-decoration: underline;
        }
        #agenda .event:hover {
            z-index:2;
        }

        #agenda .event.resize {
            cursor:ns-resize;
        }
        #agenda .event.resize .footer .resizer,
        #agenda .event.eventend:hover .footer .resizer,
        #agenda .event.eventfull:hover .footer .resizer {
            border-bottom:1px solid white;
            cursor:ns-resize;
            height:7px;
            margin:3px;
        }
        #agenda .event.dd-ghost {
            opacity: 0.5!important;
            z-index:2;
        }
        #agenda .weekdays .day-name-large {
            @apply(--paper-font-subhead);
            text-align: center;
        }
        #agenda .weekdays .day-num {
            @apply(--paper-font-headline);
        }
        #agenda canvas {
            position: absolute;
            top:0; left:0;
            width:100%;
        }

        #agenda #hours {
            position:relative;
            width:25px;
            font-family: "Oxygen Mono", Oxygen , monospace;
            font-size: .8em;
        }

        #agenda .hour {
            position:absolute;
            right:5px;
        }
        #agenda #header{
            background-color: transparent;
        }

        #agenda #header .action-button:hover {
            background-color: var(--paper-light-blue-50);
        }
        #agenda #header .action-button ::content,
        #agenda #header .action-button ::content iron-icon {
            @apply(--paper-font-button);
            color: rgb(0, 150, 136);
            margin-right: 5px;
        }
        #agenda .event .event-link {
            font-weight: bold;
        }
        #agenda .header paper-fab {
            --paper-fab-background: var(--paper-red-500);
        }
        #agenda {
            @apply(--layout-vertical);
            @apply(--layout-flex);
        }
        #agenda #header .divider {
            @apply(--layout-flex);
        }
        #agenda .weekdays {
            @apply(--layout-horizontal);
            margin-left:25px;
        }
        #agenda .weekday {
            @apply(--layout-horizontal);
            @apply(--layout-center);
            @apply(--layout-flex);
        }
        #agenda .weekday .day-name-large {
            @apply(--layout-flex);
        }
        #agenda .agendadays {
            @apply(--layout-horizontal);
            @apply(--layout-relative);
        }
        #agenda .agengaday {
            @apply(--layout-flex);
            @apply(--layout-relative);
        }
        #agenda .event {
            @apply(--layout-vertical);
        }
        #agenda .event .content{
            @apply(--layout-flex);
        }
    </style>
    <template>
        <div id="agenda">
            <div id="dialogsWrapper"></div>
            <paper-toolbar id="header" class="header">
                <paper-icon-button class="action-button" id="previous" icon="fa:caret-left" on-tap="_onPreviousWeek"></paper-icon-button>
                <paper-icon-button class="action-button" id="next" icon="fa:caret-right" on-tap="_onNextWeek"></paper-icon-button>
                <paper-button class="action-button" id="today_icon_button" on-tap="_onNowWeek"><iron-icon icon="fa:calendar-o"></iron-icon>Today</paper-button>
                <paper-button class="action-button" id="calendar_button" on-tap="_onSelectWeek"><iron-icon icon="fa:calendar"></iron-icon><span>[[_calendarWeekDisplay(_viewFrom, _viewTo)]]</span></paper-button>
                <span class="divider"></span>
                <paper-fab icon="add" class="add-patient" on-tap="redrawAll"></paper-fab>
            </paper-toolbar>
            <div id="weekdays" class="weekdays noselect">
                <template is="dom-repeat" items="[[_weekDays]]" as="day">
                    <div class="weekday noselect" data-value$="[[day.day]]">
                        <span class="day-name-large">[[_dayNameDisplay(day)]]</span>
                        <span class="day-num">[[_dayNumDisplay(day)]]</span>
                    </div>
                </template>
            </div>
            <div class="agendadays noselect" id="agendadays" style$="[[_getAgendaDaysStyle(_style.height)]]"
                 on-mousemove="_onMouseMove"
                 on-mouseover="_onDayOver"
                 on-dblclick="_onCalendarDblClick">
                <canvas id="hoursCanvas" style="width:100%"></canvas>
                <div id="hours"></div>
                <template is="dom-repeat" items="[[_weekDays]]" as="day">
                    <div style$="[[computeAgendaDayStyle(hourHeight)]]" class="agengaday noselect day" weekday
                         data-day$="[[day.day]]" data-month$="[[day.month]]" data-year$="[[day.year]]">
                        <template is="cg-repeat" items="[[_eventsInView]]" as="e"  params="[[day]]" filter="_isEventOfDay">
                            <div class$="[[_getEventClass(e, day)]]"
                                 style$="[[_getEventStyle(e, day)]]"
                                 event
                                 data-role="move"
                                 data-id$="[[e._cgaId]]"
                                 data-day$="[[day.day]]">
                                <div class="header noselect">[[_eventRangeDisplay(e, day)]]</div>
                                <div class="content noselect">
                                    <div hidden$="[[!hasProp(e, 'links', showLink, 'display')]]"><span class="event-link">[[prop(e, 'links', showLink, 'display')]]</span><br/></div>
                                    <span>[[e.label]]</span>
                                </div>
                                <div class="footer noselect" data-role="resize">
                                    <div class="resizer"></div>
                                </div>
                            </div>
                        </template>
                        <div class="dd-overlay" id$="[[concat('dd-overlay-', day.day)]]"></div>
                    </div>
                </template>
            </div>
        </div>
    </template>
</dom-module>
<script>
    (function(){
        var CollisionGroup = function(event, that, id){
            this.from = new Date(event.from);
            this.to = new Date(event.to);
            this.events = [];
            this.that = that;
            this.addEvent(event, id)
        };
        CollisionGroup.prototype = {
            reorder:function(){
                this.that.orderEvents(this.events, false);
            },
            _setId:function(event, id){
                if(id == undefined || id == null) {
                    return;
                }
                event._collisionGroupId = id;
            },
            _removeId:function(event){
                delete event._collisionGroupId;
            },
            setIds:function(id) {
                for(var i=0; i<this.events.length;i++){
                    this._setId(this.events[i], id);
                }
            },
            removeIds:function() {
                for(var i=0; i<this.events.length;i++){
                    this._removeId(this.events[i]);
                }
            },
            addEvents:function(events, id, reorder){
                for(var i=0; i<events.length; i++){
                    this.addEvent(events[i], id, reorder);
                }
            },
            addEvent:function(e, id, reorder){
                this._setId(e, id);
                this.events.push(e);
                this.from = new Date(Math.min(e.from.getTime(), this.from.getTime()));
                this.to = new Date(Math.max(e.to.getTime(), this.to.getTime()));
                reorder === true && this.reorder();
            },
            removeEvent:function(e) {
                var removed = this.events.splice(this.events.indexOf(e), 1);
                if(removed.length == 1) {
                    this._removeId(e);
                    this.reorder();
                    if (this.events.length > 0) {
                        this.from = new Date(this.events[0].from);
                        this.to = new Date(this.events[0].to);
                        for (var i = 1; i < this.events.length; i++) {
                            this.from = new Date(Math.min(this.events[i].from.getTime(), this.from.getTime()));
                            this.to = new Date(Math.max(this.events[i].to.getTime(), this.to.getTime()));
                        }
                    }
                    return true;
                }
                return false;
            }
        };

        var IdGen = function() {
            this.id = 1;
        };
        IdGen.prototype = {
            next:function(){
                return this.id++;
            },
            reset:function(){
                this.id = 1;
            }
        };
        var CalendarManager = function(collisionCacheGroups){
            this.idGen = new IdGen(),
                    this.cache = {
                        collisionGroups :{
                            enabled:collisionCacheGroups === false ? false : true,
                            idGen: new IdGen(),
                            cache:{},
                            disable:function(){
                                this.enabled = false;
                                this.flush();
                            },
                            enable:function(){
                                this.enabled = true;
                                this.flush();
                            },
                            nextId :function(){
                                return this.idGen.next();
                            },
                            size:function(){
                                return Object.keys(this.cache).length;
                            },
                            flush:function(){
                                for(var id in this.cache){
                                    this.cache[id].removeIds();
                                }
                                this.cache = {};
                                this.idGen.reset();
                            }
                        },
                        reset:function(){
                            this.collisionGroups.disable();
                        }
                    };
        };
        CalendarManager.prototype = {
            getEventsInView:function(events, view){
                var inView = [];
                events.forEach(function(e){
                    if(CG.Utils.Ranges.dateRangeIntersects(e, view)){
                        inView.push(e);
                    }
                }.bind(this));
                return inView;
            },
            minutediff:function(range) {
                return (range.to.getTime()-range.from.getTime())/(1000*60);
            },
            orderEvents:function(events, copy){
                events = copy === false ? events : events.slice();
                events.sort(this.eventComparator);
                return events;
            },
            setIds:function(events, reset){
                reset === true && this.idGen.reset();
                events.forEach(function(e){
                    this.setId(e);
                }.bind(this));
                return events;
            },
            setId:function(event) {
                event._cgaId = event._cgaId || this.idGen.next();
            },
            reset:function(){
                this.idGen.reset();
                this.cache.reset();
            },
            eventComparator:function(a,b){
                var res = CG.Utils.Comparators.dateRange(a,b);
                return res != 0 ? res : CG.Utils.Comparators.number(a._cgaId, b._cgaId);
            },
            primeCollisionGroupCache:function(events){
                console.log(this.toString(), "Priming cache");
                this.cache.collisionGroups.flush();
                var groups = this.getCollisionGroup(events);
                for(var i = 0; i < groups.length; i++){
                    var group = groups[i];
                    var id = this.cache.collisionGroups.nextId();
                    group.setIds(id);
                    this.cache.collisionGroups.cache[id] = group;
                }
                console.log(this.toString(), "Priming cache done [size " + this.cache.collisionGroups.size() + ", event count:" + events.length + "]");
            },
            invalidateCollisionGroupCache:function(event){
                //console.log("Event " + event._cgaId + " needs to be removed from cache.");
                var oldGroupId = event._collisionGroupId;
                var cachedGroup = this.cache.collisionGroups.cache[oldGroupId];
                var collisionGroup;
                if(cachedGroup && cachedGroup.removeEvent(event)) {
                    //console.log("Event " + event_cgaId + ": Cached group found, removing from it.");
                    if(cachedGroup.events.length == 0) {
                        //console.log("Event " + event._cgaId + ": Old cached group is now empty, deleting it from cache");
                        delete this.cache.collisionGroups.cache[oldGroupId];
                        collisionGroup = [cachedGroup];
                    }else{
                        //console.log("Event " + event._cgaId + ": Old cached group might needs splitting, performing collision search onto its content.");
                        var cachedGroupCollisionGroups = this.getCollisionGroup(cachedGroup.events);
                        if(cachedGroupCollisionGroups.length == 1) {
                            //console.log("Event " + event._cgaId + ": Old cached group is still a single collision group, keeping it.");
                        }else{
                            //console.log("Event " + event._cgaId + ": Old cached group is now broken into " + cachedGroupCollisionGroups.length + " distinct groups. Removing old cached group from cache and caching new ones.");
                            for(var i=0; i < cachedGroupCollisionGroups.length; i++){
                                var groupId = this.cache.collisionGroups.nextId();
                                var cachedGroupCollisionGroup = cachedGroupCollisionGroups[i];
                                cachedGroupCollisionGroup.setIds(groupId);
                                this.cache.collisionGroups.cache[groupId] = cachedGroupCollisionGroup;
                            }
                            delete this.cache.collisionGroups.cache[oldGroupId];
                        }
                        collisionGroup = cachedGroupCollisionGroups;
                    }
                }else{
                    //console.log("Event " + event._cgaId + ": Cannot remove from cache as not found cached group not found.")
                    collisionGroup = [{events:[]}];
                }
                return collisionGroup;
            },
            findCollisionGroup:function(events, event, order, flushFromCache){
                if(this.cache.collisionGroups.enabled === false) {
                    //console.log("[Cache disabled]");
                    return this.getCollisionGroup(events, event, order);
                }

                var collisionGroup;
                if(flushFromCache === true) {
                    collisionGroup = this.invalidateCollisionGroupCache(event);
                }else if(event._collisionGroupId != undefined) {
                    //console.log("Event " + event._cgaId + " has a collisionGroupId, looking it up.")
                    var cachedGroup = this.cache.collisionGroups.cache[event._collisionGroupId];
                    if(cachedGroup) {
                        //console.log("Event " + event._cgaId + " cached collision group found, using it.")
                        //console.log("[Cache HIT]");
                        collisionGroup = [cachedGroup]
                    }else{
                        //console.log("Event " + event._cgaId + " cached collision group NOT found.")
                        throw "Event " + event._cgaId + " cached collision group NOT found.";
                    }
                }else{
                    //console.log("Event " + event._cgaId + " hasn't got a collisionGroupId, trying to find suitable cached groups.");
                    var suitableCachedGroups = {};
                    var groups = 0;
                    for(var id in this.cache.collisionGroups.cache){
                        var group = this.cache.collisionGroups.cache[id];
                        if(CG.Utils.Ranges.dateRangeIntersects(event, group)) {
                            suitableCachedGroups[id] = group;
                            groups++;
                        }
                    }
                    if(groups > 0) {
                        //console.log("Event " + event._cgaId + ": found " + groups + " suitable cached groups.");
                        //console.log("[Cache HIT]");
                        if(groups == 1){
                            //console.log("Event " + event._cgaId + ": Adding it to single suitable cached group found.");
                            var groupId = Object.keys(suitableCachedGroups)[0];
                            var cachedGroup = suitableCachedGroups[groupId];
                            cachedGroup.addEvent(event, groupId, true);
                            collisionGroup = [cachedGroup];
                        }else{
                            //console.log("Event " + event._cgaId + ": More than one suitable cached group found. Merging groups and adding event");
                            var mergedGroupId = this.cache.collisionGroups.nextId();
                            var mergedGroup = new CollisionGroup(event, this, mergedGroupId);
                            for(var groupId in suitableCachedGroups){
                                mergedGroup.addEvents(suitableCachedGroups[groupId].events, mergedGroupId);
                                //console.log("Event " + event._cgaId + ": Removing stale cache group from cache");
                                delete this.cache.collisionGroups.cache[groupId];
                            }
                            mergedGroup.reorder();
                            this.cache.collisionGroups.cache[mergedGroupId] = mergedGroup;
                            collisionGroup = [mergedGroup];
                        }
                    }else{
                        //console.log("Event " + event._cgaId + ": No suitable cached groups found, performing deep collision group search and caching result.");
                        //console.log("[Cache MISS]");
                        var newGroupId = this.cache.collisionGroups.nextId();
                        collisionGroup = this.getCollisionGroup(events, event, order)[0];
                        collisionGroup.setIds(newGroupId);
                        this.cache.collisionGroups.cache[newGroupId] = collisionGroup;
                        collisionGroup = [collisionGroup];
                    }

                }
                //console.log("Cache size " + this.cache.collisionGroups.size());
                return collisionGroup;
            },
            getCollisionGroup:function(events, event, order){
                if(events.length == 0) {
                    return [];
                }
                events = order === false ? events.slice() : this.orderEvents(events);
                var index = event ? events.indexOf(event) : 0;
                if(index == -1) {
                    throw "event not found in list!";
                }
                var e = events.splice(index, 1)[0];
                var groups = [new CollisionGroup(e, this)];

                var c = 0, i, j, e, found, group;
                while(events.length > 0){
                    found = false;
                    e = events[c];
                    for(i = 0; i < groups.length; i++){
                        group = groups[i];
                        if(CG.Utils.Ranges.dateRangeIntersects(e, group)) {
                            group.addEvent(e);
                            found = true;
                            break;
                        }
                    }
                    if(!found) {
                        if(event) {
                            if(++c == events.length) {
                                events.splice(0, 1);
                                c = 0;
                            }
                        }else{
                            events.splice(0, 1);
                            groups.push(new CollisionGroup(e, this));
                        }
                    }else{
                        events.splice(c, 1);
                        c = 0;
                    }
                }
                for(i = 0; i < groups.length; i++){
                    groups[i].reorder();
                }

                return groups;
            },
            getCollisionFreeMatrix:function(collisionGroup, copy){
                var events = copy === false ? collisionGroup.events : collisionGroup.events.slice();
                var matrix = [events.splice(0,1)];
                var columnIndex = 0, column, b, found, c;
                while(events.length > 0){
                    column = matrix[columnIndex];
                    b = events[0];
                    found = false;
                    for(c = 0; c < column.length; c++){
                        if(CG.Utils.Ranges.dateRangeIntersects(column[c], b)) {
                            found = true;
                            break;
                        }
                    }
                    if(!found) {
                        column.push(b);
                        events.splice(0, 1);
                        columnIndex = 0;
                    }else{
                        columnIndex++;
                        if(columnIndex == matrix.length) {
                            matrix.push([b]);
                            events.splice(0, 1);
                            columnIndex = 0;
                        }
                    }
                }
                return matrix;
            },
            findCollisionMatrixInfoForSingleEvent:function(events, event, order, invalidateCache){
                var group = this.findCollisionGroup(events, event, order, invalidateCache);
                var matrix = this.getCollisionFreeMatrix(group[0]);
                var columnIndex = 0;
                var totalColumns = matrix.length, i, column;
                out: for(; columnIndex < matrix.length; columnIndex++){
                    column = matrix[columnIndex];
                    for(i=0; i < column.length; i++){
                        if(column[i] == event) {
                            break out;
                        }
                    }
                }
                return {
                    column:columnIndex + 1,
                    totalColumns:totalColumns
                };
            }
        };

        Polymer({
            is:"cg-agenda",
            properties:{
                colors:Object,
                cgName:{
                    type:String,
                    value:'agenda'
                },
                redrawOnApplicationEvents:{
                    type:Array,
                    value:[]
                },
                reloadOnApplicationEvents:{
                    type:Array,
                    value:[]
                },
                startDayOfWeek:{
                    type:Number,
                    value:1
                },
                showLink:String,
                hourHeight:{
                    type:Number,
                    value:60
                },
                showHour:{
                    type:Number,
                    value:9
                },
                dragMinuteStep:{
                    type:Number,
                    value:15
                },
                defaultColor: {
                    type:Object,
                    value:{name:"Bold Blue", mask:"#5484ED"}
                },
                autosize:{
                    type:Boolean,
                    value:false
                },
                locale:{
                    type:String,
                    value:window.navigator.userLanguage || window.navigator.language
                },
                highlightedFn:{
                    type:Function,
                    value:function(){return function(data){return true}}
                },
                colorFn:{
                    type:Function,
                    value:function(){return function(data){return null}}
                },

                _manager:{
                    type:CalendarManager,
                    value:new CalendarManager(true)
                },
                _dayOver:Object,
                _eventOver:Object,
                _viewFrom:Date,
                _viewTo:Date,
                _agendaObs:Object,
                _style:Object,
                _initialDragInfos:Object,
                _weekDays:{
                    type:Array,
                    value:[]
                },
                _eventsInView:{
                    type:Array,
                    value:[]
                },
                _editorSource:{
                    type:Object,
                    value:{}
                },
                _eventSizeCacheThreshold:{
                    type:Number,
                    value:50
                },
                _draggingTerminateTimeout:{
                    type:Number,
                    value:1000
                },
                _providedEvents:{
                    type:Boolean,
                    value:false,
                },
                _eventsMap:{
                    type:Object,
                    value:{}
                },
                _timeFormat : {
                    type:Intl.DateTimeFormat,
                    value:function(){
                        return Intl.DateTimeFormat(this.locale, {hour:'2-digit', minute:'2-digit', hour12:false})
                    }
                },
                _headerDateFormat : {
                    type:Intl.DateTimeFormat,
                    value:function(){
                        return Intl.DateTimeFormat(this.locale, {day:'2-digit', month:'long'})
                    }
                },
                _dayNameFormat : {
                    type:Intl.DateTimeFormat,
                    value:function(){
                        return Intl.DateTimeFormat(this.locale, {weekday:'long'})
                    }
                },
                _dayNumFormat : {
                    type:Intl.DateTimeFormat,
                    value:function(){
                        return Intl.DateTimeFormat(this.locale, {day:'2-digit'})
                    }
                },
                _monthNumFormat : {
                    type:Intl.DateTimeFormat,
                    value:function(){
                        return Intl.DateTimeFormat(this.locale, {month:'2-digit'})
                    }
                },
                date:{
                    type:Date,
                    value:new Date(),
                    observer:'dateChanged'
                },
                _events:{
                    type:Array,
                    observer:'_eventsChanged'
                },
                _layoutDrawn:{
                    type:Boolean,
                    value:false
                },
            },
            listeners:{
                track: '_onEventDrag',
                "event-drag-end":"_onEventDragEnded"
            },
            behaviors:[CG.BaseBehavior, CG.ApplicationEventBehavior, CG.ApplicationDataSourceAwareBehavior, CG.ApplicationContextBehavior],
            _isEventOfDay:CG.Utils.Ranges.dateRangeIntersects,
            ready:function(){
                this.$.datepicker = this.context.dateDialog || this.importHref("../cg-datetime-picker/cg-date-picker-dialog.html", function(){
                    this.$.datepicker = Polymer.dom(this.$.dialogsWrapper).appendChild(this.create('cg-date-picker-dialog'));
                });
                this.$.eventEditor = this.context.eventEditor || this.importHref("./cg-event-editor.html", function(){
                    this.$.eventEditor = Polymer.dom(this.$.dialogsWrapper).appendChild(this.create("cg-event-editor", {
                        categories:this.categories,
                        colors:this.colors,
                    }));
                });
                this.doWhenConditionIsMet(function(){
                    this._drawBackground();
                    this.$.weekdays.style.marginRight = (this.$.agendadays.offsetWidth - this.$.agendadays.clientWidth) + "px";
                    this.$.agendadays.scrollTop = (this.hourHeight * this.showHour);
                }, function(){return this.$.agendadays.offsetWidth != 0});
                console.log(this.toString(), "Agenda init [from:" + this._viewFrom + ", to:" + this._viewTo + "]");
            },
            computeAgendaDayStyle:function(hourHeight){
                return "height:" + (hourHeight * 24) + "px;";
            },
            attached:function(){
                this._agendaObs = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if(mutation.type != "attributes") return;
                        switch(mutation.attributeName) {
                            case "style" :
                                this._refreshStyle();
                                break;
                        }
                    }.bind(this));
                }.bind(this));
                this._agendaObs.observe(this, {
                    attributes: true,
                    attributeFilter:["style"],
                    attributeOldValue:true
                });
                this._refreshStyle();

            },
            detached:function(){
                this.super();
                this._agendaObs.disconnect();
            },
            _refreshStyle:function(){
                this._style = {
                    height:parseInt(this.style.height)
                };
            },
            _dayNumDisplay:function(day) {
                return this._dayNumFormat.format(day.date) + "/" + this._monthNumFormat.format(day.date);
            },
            _dayNameDisplay:function(day) {
                return this._dayNameFormat.format(day.date);
            },
            _calendarWeekDisplay:function(from, to){
                if(!from || !to) {
                    return;
                }
                var fromYear = from.getFullYear() != to.getFullYear() ? " " + from.getFullYear() : "";
                return this._headerDateFormat.format(from) + fromYear + " - " + this._headerDateFormat.format(to) + " " + to.getFullYear();
            },
            redrawAll:function(){
                this._eventsInView.forEach(function(e){
                    this._redrawEvent(e);
                }.bind(this));
            },
            set events(events){
                this._providedEvents = true;
                this._events = events;
            },
            reload:function(){
                var range = {from:this._viewFrom, to:this._viewTo};
                if(this._providedEvents) {
                    console.log(this.toString(), "Agenda - Events provided, using them");
                    this._setEvents(this._manager.getEventsInView(this.events, range));
                }else{
                    console.log(this.toString(), "Agenda - Events not provided, firing data request");
                    // TODO for re-render because template is not re-run on day-change and ends up with messed up rendering
                    Array.prototype.slice.call(Polymer.dom(this.root).querySelectorAll("template[is='cg-repeat']")).forEach(function(e){
                        e.render();
                    });
                    this.fireDataRequest({
                        type:"data",
                        params:range,
                        success:function(response){
                            this._setEvents(response.data);
                        }.bind(this),
                        failure:function(response){}.bind(this)
                    });
                }
            },
            onApplicationEvent:function(type, event){
                if(event.source == this) {
                    console.log(this.toString(), "onApplicationEvent(type:'"+type+"') source is self, ignoring");
                    return;
                }
                if(event.source == this._editorSource) {
                    console.log(this.toString(), "onApplicationEvent(type:'"+type+"') source is known, updating data");
                    switch(type) {
                        case "event-updated":
                        case "event-created":
                            event = event.params;
                            var newRange = {
                                from:event.from,
                                to:event.to
                            };
                            var op = type == "event-updated" ? "edit" : "create";
                            event.from = event._from || event.from;
                            event.to = event._to || event.to;
                            delete event._from;
                            delete event._to;
                            this._commitEventChange(event, newRange, op);
                            break;
                        case "event-deleted":
                            this._commitEventChange(event.params, null, "delete");
                            break;
                    }
                }else{
                    switch(type){
                        case "agenda-create-event":
                            this.createEvent(event.params);
                            break;
                        case "event-updated":
                        case "event-created":
                        case "event-deleted":
                            console.log(this.toString(), "onApplicationEvent(type:'"+type+"') source is unknown, trigger data refresh");
                            if (CG.Utils.Ranges.dateRangeIntersects(event.params, {
                                        from: this._viewFrom,
                                        to: this._viewTo
                                    })) {
                                console.log(this.toString(), "received event update. Event is in view. Refreshing datas");
                                this.reload();
                            } else {
                                console.log(this.toString(), "received event update. Event is not in view. Ignoring");
                            }
                            break;
                    }
                }
                if(this.redrawOnApplicationEvents && this.redrawOnApplicationEvents.indexOf(type) != -1) {
                    this.redrawAll();
                }
                if(this.reloadOnApplicationEvents && this.reloadOnApplicationEvents.indexOf(type) != -1) {
                    this.reload();
                }
            },
            contextChanged:function(){
                //this.redrawAll(); TODO
            },
            _setEvents:function(events){
                this._manager.orderEvents(events, false);
                this._events = this._manager.setIds(events, true);
            },
            _eventsChanged:function(){
                var eventsInView = this._events.slice();
                if(eventsInView.length < this._eventSizeCacheThreshold) {
                    console.log(this.toString(), "Event in view size (" + eventsInView.length + ") within cache threshold ("+ this._eventSizeCacheThreshold+"). Cache disabled. ");
                    this._manager.cache.collisionGroups.disable();
                }else{
                    console.log(this.toString(), "Event in view size (" + eventsInView.length + ") exceed cache threshold ("+ this._eventSizeCacheThreshold+"). Cache enabled. ");
                    this._manager.cache.collisionGroups.enable();
                    this._manager.primeCollisionGroupCache(eventsInView);
                }
                var eventsMap = {};
                eventsInView.forEach(function(e, index){
                    eventsMap[e._cgaId] = {
                        event:e,
                        index:index
                    };
                }.bind(this));

                this._eventsInView = eventsInView;
                this._eventsMap = eventsMap;
                this.redrawAll();
            },
            get events(){
                return this._events;
            },
            _onDayOver:function(e){
                var dayElement = e.target;
                while(!dayElement.hasAttribute("weekday") && dayElement != e.currentTarget) dayElement = dayElement.parentElement;
                if(dayElement == e.currentTarget) return;
                this._dayOver = {
                    day: Number(dayElement.dataset.day),
                    month: Number(dayElement.dataset.month),
                    year: Number(dayElement.dataset.year)
                };
            },
            _onMouseMove:function(e){
                var position = e.clientY - this._getAbsolutePosition(this.$.agendadays).top - this.hourHeight / 2;
                this._hoursOver = this._getHoursForHeight(position);
            },
            dateChanged:function(){
                var date = new Date(this.date.getFullYear(), this.date.getMonth(), this.date.getDate(), 0, 0, 0, 0);
                var startDay = date.getDate() - date.getDay() + (this.startDayOfWeek % 7);
                var weekDays = [];
                date.setDate(startDay);
                this._viewFrom = new Date(date);
                for(var i = startDay; i < startDay + 7; i++){
                    var from = new Date(date);
                    var to = new Date(date);
                    to.setHours(23,59,59,999);
                    weekDays.push({
                        day:date.getDate(),
                        month:date.getMonth(),
                        year:date.getFullYear(),
                        date:new Date(date),
                        from:from,
                        to:to,
                    });
                    date.setDate(date.getDate() + 1);
                }
                this._viewTo = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999);
                this._weekDays = weekDays;
                this.reload();
            },
            _onPreviousWeek:function(){
                this._addWeek(-1);
            },
            _onNextWeek:function(){
                this._addWeek(1);
            },
            _addWeek:function(weeks){
                this.date.setDate(this.date.getDate() + (weeks * 7));
                this.date = new Date(this.date);
            },
            _onNowWeek:function(){
                this.date = new Date();
            },
            _onCreateEvent:function(){
                this.createEvent();
            },
            _onSelectWeek:function(){
                this.$.datepicker.open(this.date, function(e){
                    this.date = new Date(e.detail);
                }.bind(this));
            },
            _onCalendarDblClick:function(e){
                e.stopPropagation();
                var eventElement = e.target;
                while(!eventElement.hasAttribute("event") && eventElement != e.currentTarget) eventElement = eventElement.parentElement;
                if(eventElement != e.currentTarget) {
                    return this.openEvent(eventElement.dataset.id);
                }else {
                    var event = {
                        from:new Date(this._dayOver.year, this._dayOver.month, this._dayOver.day, this._hoursOver, 0, 0 ,0),
                        to:new Date(this._dayOver.year, this._dayOver.month, this._dayOver.day, this._hoursOver + 1, 0, 0 ,0)
                    };
                    this.createEvent(event);
                }
            },
            openEvent:function(eventId){
                var event = this._getEventById(eventId).event;
                event._from = event.from;
                event._to = event.to;
                this.$.eventEditor.openDialog(event, undefined, this._editorSource);
            },
            createEvent:function(event){
                this.$.eventEditor.openDialog(event || {}, false, this._editorSource);
            },
            _onEventDragStart:function(e){
                e.preventDefault();
                e.stopPropagation();
                var eventElement = e.detail.sourceEvent.srcElement;
                var roleElement = eventElement;
                while(!roleElement.dataset.hasOwnProperty("role") && roleElement != e.target) roleElement = roleElement.parentElement;
                if(roleElement == e.target) return;

                while(!eventElement.hasAttribute("event") && eventElement != e.target) eventElement = eventElement.parentElement;
                if(eventElement == e.target) return;

                var eventId = eventElement.dataset.id;
                var event = this._getEventById(eventId).event;
                event._dragging = true;
                var eventElements = Array.prototype.slice.call(this.$.agendadays.querySelectorAll(".event[data-id='" + eventId + "']"));
                var eventElementsPerDay = {};
                for(var i = 0; i < this._weekDays.length; i++){
                    eventElementsPerDay[this._weekDays[i].day] = {
                        day:this._weekDays[i],
                        dayDDOverlayEl:this.$.agendadays.querySelector("#dd-overlay-" + this._weekDays[i].day),
                        cloneEl:null,
                        originalEl:null
                    };
                }
                eventElements.forEach(function(eventElement){
                    var day = eventElement.dataset.day;
                    var clone = eventElement.cloneNode(true);
                    eventElement.classList.add("hidden");
                    clone.classList.add("dd-ghost");
                    eventElementsPerDay[day].originalEl = eventElement;
                    eventElementsPerDay[day].cloneEl = clone;
                    eventElementsPerDay[day].dayDDOverlayEl.appendChild(clone);
                }.bind(this));

                var that = this;
                this._initialDragInfos = {
                    role: roleElement.dataset.role,
                    elements:eventElementsPerDay,
                    event:event,
                    lastDayDiff:null,
                    lastMinStep:null,
                    dayOver:this._dayOver.day,
                    lastDayOver:this._dayOver.day,
                    to:new Date(event.to),
                    from:new Date(event.from),
                    fireUpdated:function(){
                        this._cancelTask != undefined && that.cancelAsync(this._cancelTask);
                        this._cancelTask = that.async(function(){
                            this._onEventDragEnd("canceled-by-timeout");
                        }.bind(that), that._draggingTerminateTimeout);
                    },
                    fireFinished:function(){
                        this._cancelTask != undefined && that.cancelAsync(this._cancelTask);
                    }
                };
            },
            _onEventDrag:function(e){
                if(e.detail.state=='start') {
                    return this._onEventDragStart(e);
                }else if(e.detail.state=='end') {
                    return this._onEventDragEnd(e);
                }
                e.preventDefault();
                e.stopPropagation();

                if(!this._initialDragInfos) {
                    return;
                }
                var minutes = this._getMinutesForHeight(e.detail.dy);
                var to = new Date(this._initialDragInfos.to);
                to.setMinutes(this._initialDragInfos.to.getMinutes() + minutes);
                var minDiff = Math.abs((to.getTime() - this._initialDragInfos.to.getTime()) / 1000 / 60);

                if ((this._dayOver.day != this._initialDragInfos.lastDayOver) || ((minDiff >= this.dragMinuteStep || minDiff == 0) && this._initialDragInfos.lastMinStep != minDiff)) {
                    var from = new Date(this._initialDragInfos.from);
                    this._initialDragInfos.role == "move" && from.setMinutes(from.getMinutes() + minutes);

                    var dayDiff = this._dayOver.day - this._initialDragInfos.dayOver;
                    from.setDate(from.getDate() + dayDiff);
                    to.setDate(to.getDate() + dayDiff);
                    var range = {from:from, to:to};

                    var diff = this._manager.minutediff(range);
                    if(this._initialDragInfos.role == "resize" && diff < this.dragMinuteStep * 2) {
                        to.setMinutes(to.getMinutes() + Math.abs(diff) + this.dragMinuteStep * 2);
                    }

                    var oldFrom =  this._initialDragInfos.dragging ? this._initialDragInfos.dragging.from : this._initialDragInfos.from;
                    var oldTo = this._initialDragInfos.dragging ? this._initialDragInfos.dragging.to : this._initialDragInfos.to;

                    this._initialDragInfos.dragging = range;
                    this._initialDragInfos.lastMinStep = minDiff;
                    this._initialDragInfos.lastDayOver = this._dayOver.day;

                    var fromDayDiff =  from.getDate() - oldFrom.getDate();
                    var toDayDiff =  to.getDate() - oldTo.getDate();

                    var daySwapEventElements = function(dayDiff, oldDate, isFrom) {
                        if(dayDiff != 0 && this._initialDragInfos.elements.hasOwnProperty(String(oldDate.getDate()))) {
                            var el = this._initialDragInfos.elements[oldDate.getDate()].cloneEl;
                            var toDay = oldDate.getDate() + dayDiff;
                            if(this._initialDragInfos.elements.hasOwnProperty(String(toDay)) && el) {
                                var dayDef = this._initialDragInfos.elements[String(toDay)];
                                dayDiff = isFrom ? -dayDiff : dayDiff;
                                if(dayDiff > 0) {
                                    el = el.cloneNode(true);
                                    dayDef.cloneEl = el;
                                    dayDef.dayDDOverlayEl.appendChild(el);
                                }else{
                                    el.parentElement.removeChild(el);
                                    this._initialDragInfos.elements[oldDate.getDate()].cloneEl = null;
                                    if(dayDef.cloneEl == null) {
                                        dayDef.cloneEl = el;
                                        dayDef.dayDDOverlayEl.appendChild(el);
                                    }
                                }
                            }
                        }
                    }.bind(this);

                    daySwapEventElements(fromDayDiff, oldFrom, true);
                    daySwapEventElements(toDayDiff, oldTo, false);

                    for(var day in this._initialDragInfos.elements) {
                        var el = this._initialDragInfos.elements[day];
                        if(el == null || el.cloneEl == null) continue;
                        var box = this._getEventBoxFor(this._initialDragInfos.dragging, day, this._initialDragInfos.event);
                        el.cloneEl.setAttribute("style", box.toStyleString());
                        el.cloneEl.querySelector(".header").innerText = this._eventRangeDisplay(this._initialDragInfos.dragging, el.day);
                    }
                }
                this._initialDragInfos.fireUpdated();
            },
            _onEventDragEnd:function(e){
                e && typeof e != "string" && e.preventDefault() && e.stopPropagation();
                if (this._initialDragInfos && this._initialDragInfos.dragging) {
                    this._initialDragInfos.fireFinished();
                    var elements = [];
                    var overlays = [];
                    for(var day in this._initialDragInfos.elements) {
                        var el = this._initialDragInfos.elements[day];
                        if(el.cloneEl == null && el.originalEl == null) continue;
                        el.originalEl && elements.push(el.originalEl);
                        el.cloneEl && overlays.push(el.cloneEl);
                    }
                    var data = {
                        event:this._initialDragInfos.event,
                        newPosition: this._initialDragInfos.dragging,
                        elements:elements,
                        overlays:overlays
                    };
                    data.commitDrop = function(){
                        delete this.event._dragging;
                        this.elements.forEach(function(e){
                            e.classList.remove("hidden");
                        });
                        this.overlays.forEach(function(e){
                            e.parentElement.removeChild(e)
                        });
                    }.bind(data);

                    this.fire("event-drag-end", data);
                    delete this._initialDragInfos;
                }
            },
            _onEventDragEnded:function(e){
                if(this.isDataAware()) {
                    var toSave = CG.Utils.Objects.clone(false, {}, e.detail.event, e.detail.newPosition);
                    this.fireDataRequest({
                        type:"event/save", typePrefix:false,
                        params:{event:toSave},
                        success:function(response){
                            this._onEventDragEndedCommitted(e, response.data);
                        }.bind(this),
                        failure:this.reload.bind(this)
                    });
                }else{
                    this._onEventDragEndedCommitted(e);
                }
            },
            _onEventDragEndedCommitted:function(e, toFire){
                this._commitEventChange(e.detail.event, e.detail.newPosition, "edit");
                e.detail.commitDrop();
                this.fireApplicationEvent("event-updated", toFire || e.detail.event);
            },
            _redrawDeletedEvent:function(event, index){
                this.splice("_eventsInView", index, 1);
            },
            _redrawEvent:function(event){
                var ev = this._getEventById(event._cgaId);
                ev.event = CG.Utils.Objects.clone(false, {}, event);
                this.splice("_eventsInView", ev.index, 1, ev.event);
                return ev.event;
            },
            deleteEvent:function(e){
                var eventElement = e.currentTarget;
                var evt = this._getEventById(eventElement.dataset.id).event;
                this._commitEventChange(evt, undefined, "delete")
            },
            _commitEventChange:function(event, newRange, operation) {
                if(operation == "edit" || operation == "delete") {
                    var oldGroup = this._manager.findCollisionGroup(this._eventsInView, event, true, true);
                    oldGroup.forEach(function (group) {
                        group.events.forEach(function (event) {
                            //console.log("Trigger redraw for old group event: " + event._cgaId + " of group " + group.from + " - " + group.to);
                            this._redrawEvent(event);
                        }.bind(this));
                    }.bind(this));
                }

                if(operation == "edit" || operation == "create") {
                    if(operation == "create") {
                        this._manager.setId(event);
                        this._eventsInView.push(event);
                        this._events.push(event);
                        this._mapEvent(event, this._eventsInView.length - 1);

                    }
                    event.from = newRange.from;
                    event.to = newRange.to;
                    event = this._redrawEvent(event);

                    var newGroup = this._manager.findCollisionGroup(this._eventsInView, event, true);
                    newGroup.forEach(function(group){
                        group.events.forEach(function(event){
                            //console.log("Trigger redraw for new group event: " + event._cgaId + " of group " + group.from + " - " + group.to);
                            this._redrawEvent(event);
                        }.bind(this));
                    }.bind(this));
                }else if(operation == "delete"){
                    for(var i = 0; i < this._events.length; i++){
                        if(this._events[i]._cgaId == event._cgaId) {
                            this._events.splice(i, 1);
                            break;
                        }
                    }
                    var ev = this._getEventById(event._cgaId);
                    delete this._eventsMap[event._cgaId];
                    for(var id in this._eventsMap){
                        var el = this._eventsMap[id];
                        if(el.index > ev.index) {
                            el.index--;
                        }
                    }
                    this._redrawDeletedEvent(event, ev.index);
                }

                this.fire("event-changed", {
                    event:event,
                    operation:operation
                });
            },
            _eventRangeDisplay:function(range, day){
                if(!range) return;
                var from = range.from.getDate() == day.day ? this._timeFormat.format(range.from) : "";
                var to = range.to.getDate() == day.day ? this._timeFormat.format(range.to) : "";
                return from + (from && to ? " - " : "") + to;
            },
            _getEventById:function(id) {
                return this._eventsMap[id]
            },
            _mapEvent:function(event, index) {
                this._eventsMap[event._cgaId] = {
                    event:event,
                    index:index,

                };
            },
            _getEventClass:function(event, day){
                var klass =  event.from.getDate() == day.day && event.to.getDate() == day.day ? "eventfull" :
                        event.from.getDate() == day.day ? "eventstart" :
                                event.to.getDate() == day.day ? "eventend" : "eventpart";
                return "event noselect " + klass;
            },
            _getAgendaDaysStyle:function(height){
                if(!this.autosize || !this.$ || !this.$.agendadays) return "";
                height = (height - this.$.agendadays.offsetTop);
                if(isNaN(height)) return "";
                return "height:" + height + "px";
            },
            _getEventStyle:function(event, day){
//                console.log("_getEventStyle event.redraw=" + event._cgaId + " - day = " + JSON.stringify(day))
                var info = this._manager.findCollisionMatrixInfoForSingleEvent(this._eventsInView, event);
                var box = this._getEventBoxFor(event, day.day, event);
                box.left = (box.width / info.totalColumns) * (info.column - 1);
                box.width = box.width / info.totalColumns;
                return box.toStyleString();
            },
            _getEventBoxFor:function(range, day, event){
                var top = range.from.getDate() == day ? this._getHeightForDate(range.from) : 0;
                var height = this._getHeightForDate(range.to.getDate() == day ? range.to : new Date(range.to.getFullYear(), range.to.getMonth(), range.to.getDate(), 23, 59)) - top;
                var opacity = this.highlightedFn(event) ? 1.0 : .2;
                var backgroundColor = !event || !event.color || !event.color.mask ? this.colorFn(event) : undefined;

                return {
                    top:top,
                    height:height,
                    width:100,
                    left:0,
                    opacity:opacity,
                    backgroundColor:event && event.color && event.color.mask ? event.color.mask : backgroundColor ? backgroundColor.mask : this.defaultColor.mask,
                    toStyleString:function(additional){
                        return "top:" + this.top + "px;height:" + this.height + "px;width:" + this.width + "%;left:" + this.left + "%;background-color:" + this.backgroundColor + ";opacity:" + this.opacity;
                    }
                };
            },
            _getHeightForDate:function(date){
                return ((date.getHours() + (date.getMinutes() / 60.0)) * this.hourHeight);
            },
            _getMinuteHeight:function(){
                return this.hourHeight / (60.0 / this.dragMinuteStep);
            },
            _getHoursForHeight:function(height){
                return Math.floor(height / this.hourHeight);
            },
            _getMinutesForHeight:function(height){
                var minuteHeight = this._getMinuteHeight();
                return Math.round(height / minuteHeight) * this.dragMinuteStep;
            },
            _getAbsolutePosition:function(element) {
                var top = 0, left = 0;
                do {
                    top += element.offsetTop  || 0;
                    left += element.offsetLeft || 0;
                    top -= element.scrollTop  || 0;
                    left -= element.scrollLeft || 0;
                    element = element.offsetParent;
                } while(element);

                return {
                    top: top,
                    left: left
                };
            },
            _drawBackground: function() {
                this._drawBackgroundLines();
                this._drawHours();
            },
            _drawBackgroundLines:function(){
                var canvas = this.$.hoursCanvas;
                canvas.width  = this.$.agenda.offsetWidth;
                canvas.height = 24 * this.hourHeight;
                canvas.style.height = canvas.height + "px";
                var i, ctx = canvas.getContext("2d");
                ctx.lineWidth = 1;
                ctx.strokeStyle = "#eeeeee";
                for (i = 0; i < 24; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, (i + 0.5) * this.hourHeight + 0.5);
                    ctx.lineTo(canvas.width, (i + 0.5) * this.hourHeight);
                    ctx.stroke();
                }
                ctx.strokeStyle = "#ccc";
                for (i = 0; i < 24; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, (i + 1) * this.hourHeight + 0.5);
                    ctx.lineTo(canvas.width, (i + 1)* this.hourHeight);
                    ctx.stroke();
                }
            },
            _drawHours:function(){
                function pad(n, width, z) {
                    z = z || '0';
                    n = n + '';
                    return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
                }
                var i, div;
                var df = document.createDocumentFragment();
                for (i = 0; i < 24; i++) {
                    div = document.createElement("div");
                    div.classList.add("hour")
                    div.classList.add("style-scope") // todo that sucks a lot
                    div.classList.add("cg-agenda")   // todo that sucks a lot
                    div.innerHTML = pad(i, 2);
                    div.style.top = ( (i) * this.hourHeight) + "px";
                    df.appendChild(div);
                }
                this.$.hours.appendChild(df);
            }
        });
    })();
</script>